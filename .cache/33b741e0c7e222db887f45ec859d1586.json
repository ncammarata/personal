{"dependencies":[{"name":"./compat","loc":{"line":11,"column":22}}],"generated":{"js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = parser;\nexports.hasTerminalParent = hasTerminalParent;\nexports.rewindStack = rewindStack;\nexports.parse = parse;\n\nvar _compat = require('./compat');\n\nfunction parser(tokens, options) {\n  var root = { tagName: null, children: [] };\n  var state = { tokens: tokens, options: options, cursor: 0, stack: [root] };\n  parse(state);\n  return root.children;\n}\n\nfunction hasTerminalParent(tagName, stack, terminals) {\n  var tagParents = terminals[tagName];\n  if (tagParents) {\n    var currentIndex = stack.length - 1;\n    while (currentIndex >= 0) {\n      var parentTagName = stack[currentIndex].tagName;\n      if (parentTagName === tagName) {\n        break;\n      }\n      if ((0, _compat.arrayIncludes)(tagParents, parentTagName)) {\n        return true;\n      }\n      currentIndex--;\n    }\n  }\n  return false;\n}\n\nfunction rewindStack(stack, newLength, childrenEndPosition, endPosition) {\n  stack[newLength].position.end = endPosition;\n  for (var i = newLength + 1, len = stack.length; i < len; i++) {\n    stack[i].position.end = childrenEndPosition;\n  }\n  stack.splice(newLength);\n}\n\nfunction parse(state) {\n  var tokens = state.tokens,\n      options = state.options;\n  var stack = state.stack;\n\n  var nodes = stack[stack.length - 1].children;\n  var len = tokens.length;\n  var cursor = state.cursor;\n\n  while (cursor < len) {\n    var token = tokens[cursor];\n    if (token.type !== 'tag-start') {\n      nodes.push(token);\n      cursor++;\n      continue;\n    }\n\n    var tagToken = tokens[++cursor];\n    cursor++;\n    var tagName = tagToken.content.toLowerCase();\n    if (token.close) {\n      var index = stack.length;\n      var shouldRewind = false;\n      while (--index > -1) {\n        if (stack[index].tagName === tagName) {\n          shouldRewind = true;\n          break;\n        }\n      }\n      while (cursor < len) {\n        var endToken = tokens[cursor];\n        if (endToken.type !== 'tag-end') break;\n        cursor++;\n      }\n      if (shouldRewind) {\n        rewindStack(stack, index, token.position.start, tokens[cursor - 1].position.end);\n        break;\n      } else {\n        continue;\n      }\n    }\n\n    var isClosingTag = (0, _compat.arrayIncludes)(options.closingTags, tagName);\n    var shouldRewindToAutoClose = isClosingTag;\n    if (shouldRewindToAutoClose) {\n      var terminals = options.closingTagAncestorBreakers;\n\n      shouldRewindToAutoClose = !hasTerminalParent(tagName, stack, terminals);\n    }\n\n    if (shouldRewindToAutoClose) {\n      // rewind the stack to just above the previous\n      // closing tag of the same name\n      var currentIndex = stack.length - 1;\n      while (currentIndex > 0) {\n        if (tagName === stack[currentIndex].tagName) {\n          rewindStack(stack, currentIndex, token.position.start, token.position.start);\n          var previousIndex = currentIndex - 1;\n          nodes = stack[previousIndex].children;\n          break;\n        }\n        currentIndex = currentIndex - 1;\n      }\n    }\n\n    var attributes = [];\n    var attrToken = void 0;\n    while (cursor < len) {\n      attrToken = tokens[cursor];\n      if (attrToken.type === 'tag-end') break;\n      attributes.push(attrToken.content);\n      cursor++;\n    }\n\n    cursor++;\n    var children = [];\n    var position = {\n      start: token.position.start,\n      end: attrToken.position.end\n    };\n    var elementNode = {\n      type: 'element',\n      tagName: tagToken.content,\n      attributes: attributes,\n      children: children,\n      position: position\n    };\n    nodes.push(elementNode);\n\n    var hasChildren = !(attrToken.close || (0, _compat.arrayIncludes)(options.voidTags, tagName));\n    if (hasChildren) {\n      var size = stack.push({ tagName: tagName, children: children, position: position });\n      var innerState = { tokens: tokens, options: options, cursor: cursor, stack: stack };\n      parse(innerState);\n      cursor = innerState.cursor;\n      var rewoundInElement = stack.length === size;\n      if (rewoundInElement) {\n        elementNode.position.end = tokens[cursor - 1].position.end;\n      }\n    }\n  }\n  state.cursor = cursor;\n}\n//# sourceMappingURL=parser.js.map"},"hash":"f8274f443f8e7fef084006a881cd389d"}