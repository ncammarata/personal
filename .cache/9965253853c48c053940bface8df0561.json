{"dependencies":[{"name":"prop-types","loc":{"line":13,"column":22}},{"name":"react","loc":{"line":14,"column":33}},{"name":"react-dom","loc":{"line":15,"column":21}},{"name":"./FocusTrap","loc":{"line":16,"column":22}},{"name":"lodash.isboolean","loc":{"line":18,"column":19}},{"name":"lodash.isobject","loc":{"line":19,"column":21}},{"name":"lodash.isequal","loc":{"line":20,"column":20}},{"name":"./utils/sequencesFromKeyMap","loc":{"line":21,"column":32}},{"name":"./utils/hasChanged","loc":{"line":22,"column":23}},{"name":"mousetrap","loc":{"line":171,"column":30}}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _propTypes = require(\"prop-types\");\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _react = require(\"react\");\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _reactDom = require(\"react-dom\");\n\nvar _reactDom2 = _interopRequireDefault(_reactDom);\n\nvar _FocusTrap = require(\"./FocusTrap\");\n\nvar _FocusTrap2 = _interopRequireDefault(_FocusTrap);\n\nvar _lodash = require(\"lodash.isboolean\");\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _lodash3 = require(\"lodash.isobject\");\n\nvar _lodash4 = _interopRequireDefault(_lodash3);\n\nvar _lodash5 = require(\"lodash.isequal\");\n\nvar _lodash6 = _interopRequireDefault(_lodash5);\n\nvar _sequencesFromKeyMap = require(\"./utils/sequencesFromKeyMap\");\n\nvar _sequencesFromKeyMap2 = _interopRequireDefault(_sequencesFromKeyMap);\n\nvar _hasChanged = require(\"./utils/hasChanged\");\n\nvar _hasChanged2 = _interopRequireDefault(_hasChanged);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }return target;\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;\n  };\n}();\n\nfunction _objectWithoutProperties(obj, keys) {\n  var target = {};for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];\n  }return target;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }return call && ((typeof call === \"undefined\" ? \"undefined\" : _typeof(call)) === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + (typeof superClass === \"undefined\" ? \"undefined\" : _typeof(superClass)));\n  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\n/**\n * A string or list of strings, that represent a sequence of one or more keys\n * @typedef {String | Array.<String>} MouseTrapKeySequence\n * @see {@link https://craig.is/killing/mice} for support key sequences\n */\n\n/**\n * Name of a key event\n * @typedef {'keyup'|'keydown'|'keypress'} KeyEventName\n */\n\n/**\n * Options for the mapping of a key sequence and event\n * @typedef {Object} KeyEventOptions\n * @property {MouseTrapKeySequence} The key sequence required to satisfy a KeyEventMatcher\n * @property {KeyEventName} action The keyboard state required to satisfy a KeyEventMatcher\n */\n\n/**\n * A matcher used on keyboard sequences and events to trigger handler functions\n * when matching sequences occur\n * @typedef {MouseTrapKeySequence | KeyMapOptions | Array<MouseTrapKeySequence>} KeyEventMatcher\n */\n\n/**\n * A unique key to associate with KeyEventMatchers that allows associating handler\n * functions at a later stage\n * @typedef {String} ActionName\n */\n\n/**\n * A mapping from ActionNames to KeyEventMatchers\n * @typedef {Object.<String, KeyEventMatcher>} KeySequence\n */\n\n/**\n * Component that wraps it children in a \"focus trap\" and allows key events to\n * trigger function handlers when its children are in focus\n */\n\nvar HotKeys = function (_Component) {\n  _inherits(HotKeys, _Component);\n\n  function HotKeys(props, context) {\n    _classCallCheck(this, HotKeys);\n\n    /**\n     * The focus and blur handlers need access to the current component as 'this'\n     * so they need to be bound to it when the component is instantiated\n     */\n\n    var _this = _possibleConstructorReturn(this, (HotKeys.__proto__ || Object.getPrototypeOf(HotKeys)).call(this, props, context));\n\n    _this.onFocus = _this.onFocus.bind(_this);\n    _this.onBlur = _this.onBlur.bind(_this);\n    return _this;\n  }\n\n  /**\n   * Constructs the context object that contains references to this component\n   * and its KeyMap so that they may be accessed by any descendant HotKeys\n   * components\n   * @returns {{hotKeyParent: HotKeys, hotKeyMap: KeySequence}} Child context object\n   */\n\n  _createClass(HotKeys, [{\n    key: 'getChildContext',\n    value: function getChildContext() {\n      return {\n        hotKeyParent: this,\n        hotKeyMap: this.__hotKeyMap__\n      };\n    }\n\n    /**\n     * Sets this components KeyMap from its keyMap prop and the KeyMap of its\n     * ancestor KeyMap component (if one exists)\n     */\n\n  }, {\n    key: 'componentWillMount',\n    value: function componentWillMount() {\n      this.updateMap();\n    }\n\n    /**\n     * Updates this component's KeyMap if either its own keyMap prop has changed\n     * or its ancestor's KeyMap has been update\n     *\n     * @returns {boolean} Whether the KeyMap was updated\n     */\n\n  }, {\n    key: 'updateMap',\n    value: function updateMap() {\n      var newMap = this.buildMap();\n\n      if (!(0, _lodash6.default)(newMap, this.__hotKeyMap__)) {\n        this.__hotKeyMap__ = newMap;\n\n        return true;\n      }\n\n      return false;\n    }\n\n    /**\n     * This component's KeyMap merged with that of its most direct ancestor that is a\n     * HotKeys component. This component's mappings take precedence over those defined\n     * in its ancestor.\n     * @returns {KeySequence} This component's KeyMap merged with its HotKeys ancestor's\n     */\n\n  }, {\n    key: 'buildMap',\n    value: function buildMap() {\n      var parentMap = this.context.hotKeyMap || {};\n      var thisMap = this.props.keyMap || {};\n\n      /**\n       * TODO: This appears to only merge in the key maps of its most direct\n       * ancestor - what about grandparent components' KeyMap's?\n       */\n      return _extends({}, parentMap, thisMap);\n    }\n\n    /**\n     * This component's KeyMap\n     * @returns {KeySequence} This component's KeyMap\n     */\n\n  }, {\n    key: 'getMap',\n    value: function getMap() {\n      return this.__hotKeyMap__;\n    }\n\n    /**\n     * Imports mousetrap and stores a reference to it on the this component\n     */\n\n  }, {\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      // import is here to support React's server rendering as Mousetrap immediately\n      // calls itself with window and it fails in Node environment\n      var Mousetrap = require('mousetrap');\n\n      /**\n       * TODO: Not optimal - imagine hundreds of this component. We need a top level\n       * delegation point for mousetrap\n       */\n      this.__mousetrap__ = new Mousetrap(this.props.attach || _reactDom2.default.findDOMNode(this));\n\n      this.updateHotKeys(true);\n    }\n\n    /**\n     * Updates this component's KeyMap and synchronises the handlers across to\n     * Mousetrap after the component has been updated (passed new prop values)\n     * @param {Object} prevProps The props used on the component's last render\n     */\n\n  }, {\n    key: 'componentDidUpdate',\n    value: function componentDidUpdate(prevProps) {\n      this.updateHotKeys(false, prevProps);\n    }\n  }, {\n    key: 'componentWillUnmount',\n    value: function componentWillUnmount() {\n      if (this.context.hotKeyParent) {\n        this.context.hotKeyParent.childHandledSequence(null);\n      }\n\n      if (this.__mousetrap__) {\n        this.__mousetrap__.reset();\n      }\n    }\n\n    /**\n     * Updates this component's KeyMap and synchronises the changes across\n     * to Mouestrap\n     * @param {Boolean} force Whether to force an update of the KeyMap and sync\n     *        to Mousetrap, even if no relevant values appear to have changed\n     *        since the last time\n     * @param {Object} prevProps The props used on the component's last render\n     */\n\n  }, {\n    key: 'updateHotKeys',\n    value: function updateHotKeys() {\n      var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var prevProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var _props$handlers = this.props.handlers,\n          handlers = _props$handlers === undefined ? {} : _props$handlers;\n      var _prevProps$handlers = prevProps.handlers,\n          prevHandlers = _prevProps$handlers === undefined ? handlers : _prevProps$handlers;\n\n      var keyMapHasChanged = this.updateMap();\n\n      if (force || keyMapHasChanged || (0, _hasChanged2.default)(handlers, prevHandlers)) {\n        if (this.context.hotKeyParent) {\n          this.context.hotKeyParent.childHandledSequence(null);\n        }\n        this.syncHandlersToMousetrap();\n      }\n    }\n\n    /**\n     * Synchronises the KeyMap and handlers applied to this component over to\n     * Mousetrap\n     */\n\n  }, {\n    key: 'syncHandlersToMousetrap',\n    value: function syncHandlersToMousetrap() {\n      var _this2 = this;\n\n      var _props$handlers2 = this.props.handlers,\n          handlers = _props$handlers2 === undefined ? {} : _props$handlers2;\n\n      var hotKeyMap = this.getMap();\n      var sequenceHandlers = [];\n      var mousetrap = this.__mousetrap__;\n\n      // Group all our handlers by sequence\n      Object.keys(handlers).forEach(function (hotKey) {\n        var handler = handlers[hotKey];\n\n        var sequencesAsArray = (0, _sequencesFromKeyMap2.default)(hotKeyMap, hotKey);\n\n        /**\n         * TODO: Could be optimized as every handler will get called across every bound\n         * component - imagine making a node a focus point and then having hundreds!\n         */\n        sequencesAsArray.forEach(function (sequence) {\n          var action = void 0;\n\n          var callback = function callback(event, sequence) {\n            /**\n             * Check we are actually in focus and that a child hasn't already\n             * handled this sequence\n             */\n            var isFocused = (0, _lodash2.default)(_this2.props.focused) ? _this2.props.focused : _this2.__isFocused__;\n\n            if (isFocused && sequence !== _this2.__lastChildSequence__) {\n              if (_this2.context.hotKeyParent) {\n                _this2.context.hotKeyParent.childHandledSequence(sequence);\n              }\n\n              return handler(event, sequence);\n            }\n          };\n\n          if ((0, _lodash4.default)(sequence)) {\n            action = sequence.action;\n            sequence = sequence.sequence;\n          }\n\n          sequenceHandlers.push({ callback: callback, action: action, sequence: sequence });\n        });\n      });\n\n      /**\n       * TODO: Hard reset our handlers (probably could be more efficient)\n       */\n      mousetrap.reset();\n\n      sequenceHandlers.forEach(function (_ref) {\n        var sequence = _ref.sequence,\n            callback = _ref.callback,\n            action = _ref.action;\n        return mousetrap.bind(sequence, callback, action);\n      });\n    }\n\n    /**\n     * Stores a reference to the last key sequence handled by the most direct\n     * descendant HotKeys component, and passes that sequence to its own most\n     * direct HotKeys ancestor for it to do the same.\n     *\n     * This reference is stored so that parent HotKeys components do not try\n     * to handle a sequence that has already been handled by one of its\n     * descendants.\n     *\n     * @param {KeyEventMatcher} sequence The sequence handled most recently by\n     * a child HotKeys component\n     */\n\n  }, {\n    key: 'childHandledSequence',\n    value: function childHandledSequence() {\n      var sequence = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n      this.__lastChildSequence__ = sequence;\n\n      /**\n       * Traverse up any hot key parents so everyone is aware a child has\n       * handled a certain sequence\n       */\n      if (this.context.hotKeyParent) {\n        this.context.hotKeyParent.childHandledSequence(sequence);\n      }\n    }\n\n    /**\n     * Renders the component's children wrapped in a FocusTrap with the necessary\n     * props to capture keyboard events\n     *\n     * @returns {FocusTrap} FocusTrap with necessary props to capture keyboard events\n     */\n\n  }, {\n    key: 'render',\n    value: function render() {\n      var _props = this.props,\n          keyMap = _props.keyMap,\n          handlers = _props.handlers,\n          focused = _props.focused,\n          attach = _props.attach,\n          children = _props.children,\n          props = _objectWithoutProperties(_props, ['keyMap', 'handlers', 'focused', 'attach', 'children']);\n\n      return _react2.default.createElement(_FocusTrap2.default, _extends({}, props, { onFocus: this.onFocus, onBlur: this.onBlur }), children);\n    }\n\n    /**\n     * Updates the internal focused state and calls the onFocus prop if it is\n     * defined\n     */\n\n  }, {\n    key: 'onFocus',\n    value: function onFocus() {\n      this.__isFocused__ = true;\n\n      if (this.props.onFocus) {\n        var _props2;\n\n        (_props2 = this.props).onFocus.apply(_props2, arguments);\n      }\n    }\n\n    /**\n     * Updates the internal focused state and calls the onBlur prop if it is\n     * defined.\n     *\n     * Also registers a null sequence as being handled by this component with\n     * its ancestor HotKeys.\n     */\n\n  }, {\n    key: 'onBlur',\n    value: function onBlur() {\n      this.__isFocused__ = false;\n\n      if (this.props.onBlur) {\n        var _props3;\n\n        (_props3 = this.props).onBlur.apply(_props3, arguments);\n      }\n\n      if (this.context.hotKeyParent) {\n        this.context.hotKeyParent.childHandledSequence(null);\n      }\n    }\n  }]);\n\n  return HotKeys;\n}(_react.Component);\n\nHotKeys.propTypes = {\n  /**\n   * A map from action names to Mousetrap key sequences\n   */\n  keyMap: _propTypes2.default.object,\n\n  /**\n   * A map from action names to event handler functions\n   */\n  handlers: _propTypes2.default.object,\n\n  /**\n   * Whether HotKeys should behave as if it has focus in the browser,\n   * whether it does or not - a way to force focus behaviour\n   */\n  focused: _propTypes2.default.bool,\n\n  /**\n   * The DOM element the keyboard listeners should be attached to\n   */\n  attach: _propTypes2.default.any,\n\n  /**\n   * Children to wrap within a focus trap\n   */\n  children: _propTypes2.default.node,\n\n  /**\n   * Function to call when this component gains focus in the browser\n   */\n  onFocus: _propTypes2.default.func,\n\n  /**\n   * Function to call when this component loses focus in the browser\n   */\n  onBlur: _propTypes2.default.func\n};\nHotKeys.childContextTypes = {\n  /**\n   * Reference to this instance of HotKeys so that any descendents are aware\n   * that they are being rendered within another HotKeys component\n   */\n  hotKeyParent: _propTypes2.default.any,\n\n  /**\n   * Reference to this instance's KeyMap so that any descendents may merge it\n   * into its own\n   */\n  hotKeyMap: _propTypes2.default.object\n};\nHotKeys.contextTypes = {\n  /**\n   * Reference to the most direct ancestor that is a HotKeys component (if one\n   * exists) so that messages may be passed to it when necessary\n   */\n  hotKeyParent: _propTypes2.default.any,\n\n  /**\n   * Reference to the KeyMap of its most direct HotKeys ancestor, so that it may\n   * be merged into this components\n   */\n  hotKeyMap: _propTypes2.default.object\n};\n\nexports.default = HotKeys;"},"hash":"80e8be668218acc0c6e27288aa435075"}