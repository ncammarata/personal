{"dependencies":[{"name":"react","loc":{"line":11,"column":37}},{"name":"./HotKeys","loc":{"line":12,"column":20}}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _react = require(\"react\");\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _HotKeys = require(\"./HotKeys\");\n\nvar _HotKeys2 = _interopRequireDefault(_HotKeys);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }return target;\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }return call && ((typeof call === \"undefined\" ? \"undefined\" : _typeof(call)) === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + (typeof superClass === \"undefined\" ? \"undefined\" : _typeof(superClass)));\n  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\n/**\n * withHotKeys is an HOC that provides the wrappedComponent with the ability to implement keyboard actions\n * without the user wrapping every component with a <HotKeys> component individually\n *\n * See examples/master/HOCWrappedNode.js for an example implementation\n * Follow the steps below to use the HOC:\n *\n * @example <caption>Example usage of withHotKeys.</caption>\n * // Returns the HOC-wrapped component.\n * // 1. Declared a key map that with the actionName as key and keyboardKeys as values\n * const ACTION_KEY_MAP = {\n *     'logConsole' : 'down',\n * };\n *\n * class BasicBox extends React.Component {\n *\n * // 2. declare 'hotKeyHandlers' within the Component's class definition\n *   hotKeyHandlers: {\n *     'logConsole': this.logConsole.bind(this),\n *   }\n *\n *   logConsole() {\n *     console.log('a hotkey is pressed');\n *   }\n *\n *   render() {\n *     return (\n *         <div tabIndex=\"0\">\n *             Press the down arrow\n *         </div>\n *     );\n *   }\n * }\n *\n * // 3. Wrap the Component with withHotKeys\n * export default withHotKeys(ACTION_KEY_MAP)(BasicBox);\n * @returns {function} Returns the HOC-wrapped component.\n *\n * @param {Object} keyMap an action-to-keyboard-key mapping\n * @summary An HOC that provides the wrappedComponent with the ability to implement keyboard actions\n */\nvar withHotKeys = function withHotKeys(keyMap) {\n  return function (Component) {\n    return function (_PureComponent) {\n      _inherits(HotKeysWrapper, _PureComponent);\n\n      function HotKeysWrapper(props) {\n        _classCallCheck(this, HotKeysWrapper);\n\n        var _this = _possibleConstructorReturn(this, (HotKeysWrapper.__proto__ || Object.getPrototypeOf(HotKeysWrapper)).call(this, props));\n\n        _this._setRef = _this._setRef.bind(_this);\n        _this.state = {\n          handlers: {}\n        };\n        return _this;\n      }\n\n      _createClass(HotKeysWrapper, [{\n        key: 'componentDidMount',\n        value: function componentDidMount() {\n          this.setState({ handlers: this._ref.hotKeyHandlers });\n        }\n      }, {\n        key: '_setRef',\n        value: function _setRef(node) {\n          this._ref = node;\n        }\n      }, {\n        key: 'render',\n        value: function render() {\n          var handlers = this.state.handlers;\n\n          // Setting component as documentfragment to avoid unexpected stylistic changes to the wrapped component\n\n          return _react2.default.createElement(_HotKeys2.default, { component: 'document-fragment', keyMap: keyMap, handlers: handlers }, _react2.default.createElement(Component, _extends({\n            ref: this._setRef\n          }, this.props)));\n        }\n      }]);\n\n      return HotKeysWrapper;\n    }(_react.PureComponent);\n  };\n};\n\nexports.default = withHotKeys;"},"hash":"bdd526792eb031b7fe4e35bebcca8b6d"}